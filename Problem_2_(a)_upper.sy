;; The background theory is linear Real arithmetic
(set-logic LRA)

;; Name and signature of the function to be synthesized
;;upper
(synth-fun Tf_upper ((l Real) (u Real)) Real
    
    ;; Declare the non-terminals that would be used in the grammar
    ((I Real) (B Bool))

    ;; Define the grammar for allowed implementations of max2
    ((I Real (l u 0 (- l) (- u) (+ I I) (- I I) (ite B I I)))
     (B Bool ((= I I) (> I I) (<= I I) (< I I) (>= I I))))
)




(declare-var l Real)
(declare-var u Real)

;; Define the semantic constraints on the function
;;upper
(constraint (=> (<= l u) (>= (Tf_upper l u) 0)))
(constraint (=> (and (<= l u) (>= l 0))
                    (= (Tf_upper l u) u)
            )
)

(constraint (=> (and (<= l u) (< u 0))
                    (= (Tf_upper l u) (- l))
            )
)
(constraint (=> (<= l u) (>= (Tf_upper l u) (ite (>= (- l) u) (- l) u) )))

(check-synth)






;;1st attempt:
;; Define the semantic constraints on the function
;;upper
;;(constraint (=> (<= l u) (>= (Tf_upper l u) 0)))
;;(constraint (=> (and (<= l u) (>= l 0) (>= u 0))
;;                    (= (Tf_upper l u) u)
;;            )
;;)
;;(constraint (=> (and (<= l u) (< l 0) (> u 0))
;;                        (= (Tf_upper l u) (ite (> (- l) u) (- l) u)))
;;            
;;)
;;(constraint (=> (and (<= l u) (< l 0) (< u 0))
;;                    (= (Tf_upper l u) (- l))
;;            )
;;)
;;(constraint (=> (<= l u) (>= (Tf_upper l u) l)))
;;(constraint (=> (<= l u) (>= (Tf_upper l u) u)))



;;result:
;;((define-fun Tf_upper ((l Real) (u Real)) Real (let ((_let_1 (- l))) (ite (<= u _let_1) _let_1 u))))